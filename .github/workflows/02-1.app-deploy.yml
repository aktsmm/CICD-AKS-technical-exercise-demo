name: 2-1. Build and Deploy Application

on:
  # „Ç¢„Éó„É™„Ç≥„Éº„Éâ„ÅÆ„Åø„ÅÆÂ§âÊõ¥ÊôÇ„ÅØÁõ¥Êé•ÂÆüË°å
  push:
    branches:
      - main
    paths:
      - "app/**"
      - ".github/workflows/02-1.app-deploy.yml"
  workflow_dispatch:
  # InfrastructureÂÆå‰∫ÜÂæå„Å´Ëá™ÂãïÂÆüË°å
  workflow_run:
    workflows: ["1. Deploy Infrastructure"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: read
  security-events: write

env:
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}
  RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}

jobs:
  quality-check:
    name: Lint and Unit Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Dependencies
        working-directory: app
        run: npm ci

      - name: Run Lint and Tests
        working-directory: app
        run: npm test

  codeql-analysis:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: javascript
        continue-on-error: true # ‚úÖ Áµ±‰∏Ä: ÂàùÊúüÂåñÂ§±Êïó„Åß„ÇÇ„Ç∏„Éß„ÉñÁ∂öË°å

      - name: Install Node.js Dependencies
        working-directory: app
        run: npm ci

      - name: Autobuild
        uses: github/codeql-action/autobuild@v4
        continue-on-error: true # ‚úÖ Áµ±‰∏Ä: „Éì„É´„ÉâÂ§±Êïó„Åß„ÇÇ„Ç∏„Éß„ÉñÁ∂öË°å

      - name: Analyze
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:javascript"
        continue-on-error: true # ‚úÖ Áµ±‰∏Ä: Ëß£ÊûêÂ§±Êïó„Åß„ÇÇ„Ç∏„Éß„ÉñÁ∂öË°å

  scan-container:
    name: Scan Container Image
    runs-on: ubuntu-latest
    # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Build Docker Image (for scanning)
        run: |
          cd app
          docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} .

      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"
          exit-code: 0 # ‚úÖ Áµ±‰∏Ä: Ê§úÂá∫„Åå„ÅÇ„Å£„Å¶„ÇÇexit code 0
        continue-on-error: true # ‚úÖ Áµ±‰∏Ä: „Çπ„Ç≠„É£„É≥Â§±Êïó„Åß„ÇÇ„Ç∏„Éß„ÉñÁ∂öË°å

      - name: Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        continue-on-error: true
        with:
          sarif_file: trivy-results.sarif

  build-push:
    name: Build and Push to ACR
    runs-on: ubuntu-latest
    needs:
      - scan-container
      - codeql-analysis
      - quality-check
    # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    outputs:
      image_tag: ${{ steps.image.outputs.tag }}
      acr_name: ${{ steps.get_acr.outputs.acr_name }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login (Service Principal)
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get ACR Name
        id: get_acr
        run: |
          # „É™„ÇΩ„Éº„Çπ„Ç∞„É´„Éº„Éó„ÅÆÂ≠òÂú®Á¢∫Ë™çÔºàÊúÄÂ§ß10Âõû„É™„Éà„É©„Ç§„ÄÅ30ÁßíÈñìÈöîÔºâ
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
              echo "üîç Attempt $attempt/$max_attempts: Checking resource group..."
              
              if az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
                  echo "‚úÖ Resource group ${{ env.RESOURCE_GROUP }} found!"
                  break
              fi
              
              if [ $attempt -eq $max_attempts ]; then
                  echo "‚ùå Resource group ${{ env.RESOURCE_GROUP }} not found after $max_attempts attempts!"
                  echo "Infrastructure deployment may not have completed yet."
                  exit 1
              fi
              
              echo "‚è≥ Resource group not found. Waiting 30 seconds..."
              sleep 30
              attempt=$((attempt + 1))
          done

          # ACR„ÅÆÂèñÂæóÔºàÊúÄÂ§ß20Âõû„É™„Éà„É©„Ç§„ÄÅ30ÁßíÈñìÈöî = ÊúÄÂ§ß10ÂàÜÂæÖÊ©üÔºâ
          max_acr_attempts=20
          acr_attempt=1
          ACR_NAME=""

          while [ $acr_attempt -le $max_acr_attempts ]; do
              echo "üîç Attempt $acr_attempt/$max_acr_attempts: Checking ACR..."
              
              ACR_NAME=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
              
              if [ -n "$ACR_NAME" ]; then
                  echo "‚úÖ ACR found: ${ACR_NAME}"
                  break
              fi
              
              if [ $acr_attempt -eq $max_acr_attempts ]; then
                  echo "‚ùå No ACR found in resource group ${{ env.RESOURCE_GROUP }} after $max_acr_attempts attempts!"
                  echo "Infrastructure deployment may still be in progress."
                  echo "üí° Hint: ACR creation typically takes 5-10 minutes after resource group creation."
                  exit 1
              fi
              
              echo "‚è≥ ACR not found yet. Waiting 30 seconds... (This is normal, ACR creation takes time)"
              sleep 30
              acr_attempt=$((acr_attempt + 1))
          done

          echo "ACR Name: ${ACR_NAME}"
          echo "acr_name=${ACR_NAME}" >> $GITHUB_OUTPUT

      - name: Login to ACR
        run: |
          az acr login --name ${{ steps.get_acr.outputs.acr_name }}

      - name: Build and Push Image
        id: image
        run: |
          cd app
          IMAGE_TAG="${{ github.sha }}"
          ACR_NAME="${{ steps.get_acr.outputs.acr_name }}"
          FULL_IMAGE="${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"

          docker build -t $FULL_IMAGE .
          docker push $FULL_IMAGE

          # Tag as latest
          docker tag $FULL_IMAGE ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest
          docker push ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest

          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

  deploy-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-push
    # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    environment:
      name: aks-demo
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login (Service Principal)
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Infrastructure Details
        id: infra
        run: |
          echo "Querying Azure for infrastructure details..."

          # AKS„ÇØ„É©„Çπ„Çø„ÉºÂêç„ÇíÂèñÂæó
          AKS_CLUSTER_NAME=$(az aks list -g ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)

          # MongoDB VM„ÅÆ„Éó„É©„Ç§„Éô„Éº„ÉàIP„ÇíÂèñÂæóÔºàVNetÂÜÖÈÄö‰ø°Áî®Ôºâ
          MONGO_VM_IP=$(az vm list-ip-addresses -g ${{ env.RESOURCE_GROUP }} -n vm-mongo-dev --query "[0].virtualMachine.network.privateIpAddresses[0]" -o tsv)

          echo "AKS Cluster: ${AKS_CLUSTER_NAME}"
          echo "MongoDB VM IP: ${MONGO_VM_IP}"

          echo "aks_name=${AKS_CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "mongo_ip=${MONGO_VM_IP}" >> $GITHUB_OUTPUT

      - name: Wait for AKS API to Become Ready
        run: |
          RG='${{ env.RESOURCE_GROUP }}'
          CLUSTER='${{ steps.infra.outputs.aks_name }}'

          if [ -z "$CLUSTER" ]; then
            echo "AKS cluster name is empty. Ensure infrastructure deployment completed."
            exit 1
          fi

          echo "Waiting for AKS control plane to reach Succeeded state..."
          max_attempts=30
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            state=$(az aks show --resource-group "$RG" --name "$CLUSTER" --query provisioningState -o tsv)
            echo "Attempt $attempt/$max_attempts => $state"

            if [ "$state" == "Succeeded" ]; then
              echo "AKS provisioning completed."
              break
            fi

            if [ "$state" == "Failed" ]; then
              echo "AKS provisioning failed. Aborting deployment."
              exit 1
            fi

            if [ $attempt -eq $max_attempts ]; then
              echo "AKS did not reach Succeeded within expected time."
              exit 1
            fi

            sleep 30
            attempt=$((attempt + 1))
          done

      - name: Prepare Kubernetes Manifests
        env:
          ACR_NAME: ${{ needs.build-push.outputs.acr_name }}
          IMAGE_TAG: ${{ needs.build-push.outputs.image_tag }}
        run: |
          mkdir -p rendered
          cp app/k8s/deployment.yaml rendered/deployment.yaml
          cp app/k8s/service.yaml rendered/service.yaml
          cp app/k8s/ingress.yaml rendered/ingress.yaml
          cp app/k8s/rbac-vulnerable.yaml rendered/rbac-vulnerable.yaml
          cp app/k8s/ingress-nginx-controller.yaml rendered/ingress-nginx-controller.yaml

          sed -i "s|<ACR_NAME>|${ACR_NAME}|g" rendered/deployment.yaml
          sed -i "s|<IMAGE_NAME>|${{ env.IMAGE_NAME }}|g" rendered/deployment.yaml
          sed -i "s|<IMAGE_TAG>|${IMAGE_TAG}|g" rendered/deployment.yaml

      - name: Render Mongo Credentials Secret
        env:
          MONGO_ADMIN_PASSWORD: ${{ secrets.MONGO_ADMIN_PASSWORD }}
        run: |
          mkdir -p rendered
          cat <<'EOF' > rendered/mongo-secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: mongo-credentials
            namespace: default
          type: Opaque
          stringData:
            uri: PLACEHOLDER
            username: mongoadmin
          EOF

          URI="mongodb://mongoadmin:${MONGO_ADMIN_PASSWORD}@${{ steps.infra.outputs.mongo_ip }}:27017/guestbook?authSource=admin"
          sed -i "s|PLACEHOLDER|${URI}|g" rendered/mongo-secret.yaml

      - name: Apply Core Manifests via AKS Command Invoke
        run: |
          RG='${{ env.RESOURCE_GROUP }}'
          CLUSTER='${{ steps.infra.outputs.aks_name }}'

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f mongo-secret.yaml" \
            --file rendered/mongo-secret.yaml

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f ingress-nginx-controller.yaml" \
            --file rendered/ingress-nginx-controller.yaml

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f rbac-vulnerable.yaml" \
            --file rendered/rbac-vulnerable.yaml

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f deployment.yaml" \
            --file rendered/deployment.yaml

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f service.yaml" \
            --file rendered/service.yaml

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f ingress.yaml" \
            --file rendered/ingress.yaml

      - name: Wait for Deployment via Control Plane
        run: |
          RG='${{ env.RESOURCE_GROUP }}'
          CLUSTER='${{ steps.infra.outputs.aks_name }}'

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=120s" \
            || echo "‚ö†Ô∏è Ingress Controller readiness timed out"

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl rollout status deployment/guestbook-app --timeout=5m"

      - name: Configure HTTPS with cert-manager
        id: tls
        run: |
          RG='${{ env.RESOURCE_GROUP }}'
          CLUSTER='${{ steps.infra.outputs.aks_name }}'

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml"

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl wait --namespace cert-manager --for=condition=ready pod --selector=app.kubernetes.io/instance=cert-manager --timeout=120s" \
            || echo "‚ö†Ô∏è cert-manager readiness timed out"

          cat <<'EOF' > rendered/cluster-issuer.yaml
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: selfsigned-issuer
          spec:
            selfSigned: {}
          EOF

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f cluster-issuer.yaml" \
            --file rendered/cluster-issuer.yaml

          INGRESS_IP=$(az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}'" \
            --query "logs" -o tsv)

          if [ -z "$INGRESS_IP" ]; then
            echo "‚è≥ Waiting for External IP..."
            sleep 30
            INGRESS_IP=$(az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
              --command "kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}'" \
              --query "logs" -o tsv)
          fi

          if [ -z "$INGRESS_IP" ]; then
            echo "‚ùå Could not get Ingress IP. Skipping TLS configuration."
            exit 0
          fi

          DOMAIN="${INGRESS_IP}.nip.io"
          echo "üì° Using domain: ${DOMAIN}"

          echo "ip=${INGRESS_IP}" >> $GITHUB_OUTPUT

          cat <<EOF > rendered/ingress-tls.yaml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: guestbook-ingress
            namespace: default
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
              cert-manager.io/cluster-issuer: selfsigned-issuer
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - ${DOMAIN}
                secretName: guestbook-tls-cert
            rules:
              - host: ${DOMAIN}
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: guestbook-service
                          port:
                            number: 80
              - http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: guestbook-service
                          port:
                            number: 80
          EOF

          az aks command invoke --resource-group "$RG" --name "$CLUSTER" \
            --command "kubectl apply -f ingress-tls.yaml" \
            --file rendered/ingress-tls.yaml

          echo "domain=${DOMAIN}" >> $GITHUB_OUTPUT

      - name: Publish Deployment Summary
        env:
          SUMMARY_DOMAIN: ${{ steps.tls.outputs.domain }}
          SUMMARY_IP: ${{ steps.tls.outputs.ip }}
          INGRESS_IP_JSON: ${{ steps.tls.outputs.raw_result }}
        run: |
          set -euo pipefail
          RG='${{ env.RESOURCE_GROUP }}'
          CLUSTER='${{ steps.infra.outputs.aks_name }}'

          PODS='‚ö†Ô∏è kubectl „Åã„Çâ„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
          if POD_OUTPUT=$(az aks command invoke --resource-group "$RG" --name "$CLUSTER" --command "kubectl get pods -n default -l app=guestbook -o wide" --query "logs" -o tsv 2>&1); then
            PODS="$POD_OUTPUT"
          else
            echo "‚ö†Ô∏è az aks command invoke „Åß Pod ÊÉÖÂ†±ÂèñÂæó„Å´Â§±Êïó: $POD_OUTPUT"
          fi

          DOMAIN_LINE="${SUMMARY_DOMAIN}"
          if [ -z "$DOMAIN_LINE" ]; then
            DOMAIN_LINE='Pending IP allocation'
          fi

          HTTPS_URL='Pending IP allocation'
          if [ -n "$SUMMARY_DOMAIN" ]; then
            HTTPS_URL="https://$SUMMARY_DOMAIN"
          fi

          HTTP_URL='Pending IP allocation'
          if [ -n "$SUMMARY_IP" ]; then
            HTTP_URL="http://$SUMMARY_IP"
          else
            RAW=$(echo "$INGRESS_IP_JSON" | awk -F'[\[\]]' '{print $2}' | awk -F"'" '{print $2}')
            if [ -z "$RAW" ]; then
              # ARM API „Åã„Çâ Public IP „ÇíÂèñÂæó„Åó„Å¶„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØË°®Á§∫
              NODE_RG=$(az aks show --resource-group "$RG" --name "$CLUSTER" --query nodeResourceGroup -o tsv)
              RAW=$(az network public-ip list --resource-group "$NODE_RG" --query "[?ipAddress!='' ].ipAddress | [0]" -o tsv || true)
            fi
            if [ -n "$RAW" ]; then
              HTTP_URL="http://$RAW"
            fi
          fi

          {
            echo "### Deployment Summary"
            echo "- Cluster: ${CLUSTER}"
            echo "- Mongo VM IP: ${{ steps.infra.outputs.mongo_ip }}"
            echo "- Domain: ${DOMAIN_LINE}"
            echo "- HTTPS: ${HTTPS_URL}"
            echo "- HTTP: ${HTTP_URL}"
            echo "- Image: ${{ needs.build-push.outputs.acr_name }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ needs.build-push.outputs.image_tag }}"
            echo "- Pods:" 
            echo '```'
            echo "$PODS"
            echo '```'
          } >> $GITHUB_STEP_SUMMARY

          # Exit here to prevent legacy inline commands from executing
          exit 0
